/**********************************************Simplificacions:- Els tags s—n strings, no poden haver tags repetits simultˆniament  (podem, per˜, fer servir un tag mŽs d'un cop si no estan vigents a  l'hora).- No es poden fer servir non-local exits (continuacions, excepcions,  etc)Al tanto! S’ que es poden fer servir continuacions en la*implementaci—* de my_catch i my_throw (de fet, no teniu mŽs remei!),el que vull dir Žs que en el codi que fa servir my_catch i/o my_throw,no ha d'haver non-local exits. Aix˜ simplifica molt la implementaci—.**********************************************/function current_continuation() { // Sempre va bŽ tenir current_continuation a mˆ...    return new Continuation()}// La definici— de my_catch i my_throwlet { my_catch, my_throw } =    ( function () {        // ... les dades/atributs/estat necessaris (a decidir per vosaltres)        let tags = []        let cc = current_continuation()        // ... les funcions auxiliars que us facin falta (a decidir per vosaltres)      function _catch(tag, fun) {        //print("ejecuto catch")        // Pre: tag Žs una String; fun Žs un Thunk        tags.push(tag)        if (cc instanceof Continuation) {          return fun()        }        else {          //print("entro en el else catch")          return cc          //print("imprimi el cc")        }      }        function _throw(tag, val) {            // Pre: tag Žs una String; val Žs qualsevol valor (per˜ no una Continuation!)            // ...            //print(`etiquetas: {${tags}}`)            const index = tags.findIndex((element) => element === tag)            if (index !== -1) {              //print("if del throw")              tags.splice(index,1)              cc(val)            }            else {              //print("else del throw")              tags.splice(0,tags.length)              return            }        }        return { my_catch: _catch, my_throw: _throw }    }())// Els exemples de l'enunciat:// a///print(my_catch('etiqueta',function () { return 2 + 3 * 100 })) // ==> escriu 302//print(my_catch('etiqueta',function () {return 2 + 3 * my_throw('etiqueta',100)})) // ==> escriu 100// b/function test(x) {    return 2 + 3 * (x === 0 ? my_throw('etiqueta',100) : 100)}//print(my_catch('etiqueta', function() { return test(1) }))  // escriurˆ 302//print(my_catch('etiqueta', function() { return test(0) }))  // escriurˆ 100//print(test(0)) // generarˆ un error, per tant caldrˆ comentar aquest codi si voleu provar l'apartat c// cfunction getRandomInt(max) {  return Math.floor(Math.random() * max);}function check(x) {  print(`valor del check: ${x}`)    if (x === 0) {        my_throw('zero','zero')    } else if (x === 1) {        my_throw('one','one')    }    return x}print(my_catch('zero',function() {    for (let i = 0; i < 10; i++) {      print(my_catch('one', function () { return check(getRandomInt(5)) }) )}    return 'finito'}))